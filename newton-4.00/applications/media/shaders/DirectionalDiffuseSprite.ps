/* Copyright (c) <2003-2016> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/  
   
#version 330 core

//uniform vec4 directionalLightDir;

in vec4 quadUV;
in vec4 quadColor;
out vec4 pixelColor;

void main()
{
	float r2 = dot(quadUV, quadUV);
	if (r2 > 1.0) 
	{	
		discard; 
	}

	vec3 normalInPixelSpace = vec3(quadUV.x, quadUV.y, sqrt (1.0 - r2));

	// TODO
	// here I nee to rest the z buffer and prevent z fitgting

	// TODO
	// now I need the light vector also in pixel space
	// which should be an interpolated input, 
	// for now just hack a fix value
	vec3 directionalLightDir = vec3(0.71, 0.71, 0.0);
	float difusse = max (dot(normalInPixelSpace, directionalLightDir), 0.3) ;

	pixelColor = quadColor * difusse;
}